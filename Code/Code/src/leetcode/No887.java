package leetcode;
/**
 * 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
 *
 * 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
 *
 * 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
 *
 * 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
 *
 * 你的目标是确切地知道 F 的值是多少。
 *
 * 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
 *
 *  
 *
 * 示例 1：
 *
 * 输入：K = 1, N = 2
 * 输出：2
 * 解释：
 * 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
 * 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
 * 如果它没碎，那么我们肯定知道 F = 2 。
 * 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
 * 示例 2：
 *
 * 输入：K = 2, N = 6
 * 输出：3
 * 示例 3：
 *
 * 输入：K = 3, N = 14
 * 输出：4
 *
 */
public class No887 {

    /**
     * 二分查找思想+递归思想
     * K 个鸡蛋，N 层楼
     * 首先在中间位置 (N+1)/2 尝试
     * 好情况是没碎，目标在上面楼层，则问题变为 K 个鸡蛋，N-(N+1)/2 层楼 的次数 +1
     * 坏情况是碎了，目标在下面楼层，则问题变为 K-1 个鸡蛋，(N+1)/2-1 层楼 的次数 +1
     * 我们需要考虑最坏情况，所以选择其中较大值进行递归
     * 状态转移 f(K,N)=max(f(K,N-(N+1)/2),f(K-1,(N+1)/2-1))+1
     * 最后确定初始状态
     * 当我们只有 1 个鸡蛋时，只能从下到上一层一层尝试
     * f(1,N)=N
     * 或者只剩 1 层楼时，无论有多少鸡蛋，只需要尝试一次
     * f(K,1)=1
     * 同样 f(K,0)=0
     * <p>
     * <p>
     * 但是，二分并不是最优解
     * 比如 2 个鸡蛋，9 层楼
     * 二分法第一次在 5 层尝试，总共需要 5 次
     * 但是第一次在 4 层尝试，则总共需要 4 次
     * 所以我们假设在位置 X 尝试
     * 好情况是没碎，目标在上面楼层，则问题变为 K 个鸡蛋，N-X 层楼 的次数 +1
     * 坏情况是碎了，目标在下面楼层，则问题变为 K-1 个鸡蛋，X-1 层楼 的次数 +1
     * 状态转移方程多了一个参数，我们需要调整 X 的值，找到
     * max(f(K,N-X),f(K-1,X-1))+1 的最小值
     * 即为 f(K,N) 的值
     * 但时间复杂度太高，所以在调整 X 值找最小值时我们可以采用二分查找
     * 显而易见，X 递增时，f(K,N-X) 递减， f(K-1,X-1) 递增
     * 因此 max(f(K,N-X),f(K-1,X-1)) 的最小值出现在两条线的交叉点，交叉点的特征是相邻两个 X 的值决定的两个等式大小相反
     * X2=X1+1，f(K,N-X1)<f(K-1,X1-1) 且 f(K,N-X2)>f(K-1,X2-1)
     * <p>
     * <p>
     * 上面方法总体写起来太复杂，我们换个思路，假设知道 X
     * g(K,X) 表示 K 个鸡蛋 X 次尝试能够确定的最大楼层数
     * 那么我们只需要找到使 g(K,X)>=N 成立的最小 X 值
     * 然后肯定是动态规划了
     * g(K,X) 如果我们尝试的这个鸡蛋
     * 碎了，我们需要从这层楼下面继续尝试，而这层楼下面最多有 g(K-1,X-1) 层
     * 没碎，我们需要从这层楼上面继续尝试，而这层楼上面最多有 g(K,X-1) 层
     * 那么 g(K,X)=g(K-1,X-1)+g(K,X-1)+1
     * 初始状态
     * g(1,X)=X
     * g(K,1)=1
     * 而且 X 是个不大于 N 的数字
     */
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        if (K == 1) {
            return N;
        }
        if (N == 1) {
            return 1;
        }
        for (int i = 1; i < K + 1; i++) {
            dp[i][1] = 1;
        }
        for (int i = 1; i < N + 1; i++) {
            dp[1][i] = i;
        }
        for (int i = 2; i < N + 1; i++) {
            for (int j = 2; j < K + 1; j++) {
                dp[j][i] = dp[j - 1][i - 1] + dp[j][i - 1] + 1;
                if (dp[j][i] >= N) {
                    return i;
                }
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        No887 no887 = new No887();
        //System.out.println(no887.superEggDrop(2,4));
        //System.out.println(no887.superEggDrop(4,2));
        System.out.println(no887.superEggDrop(1,2));
    }
}
