【创建和销毁对象】
1·考虑用静态工厂方法代替构造器
提供静态工厂方法而不是公有的构造器
静态工厂方法比构造器优势：有名称；不必每次调用创建新对象；返回任何子类型对象；创建参数化类型实例时，代码更简洁。
Map<String,List<String>> m = new HashMap<String,List<String>>();
类型推导type inference
public static <K,V> HashMap<K,V> newInstance{
	return new HashMap<K,V>();
}
Map<String,List<String>> m = HashMap.newInstance();
缺点：类如果不含公有的或者受保护的构造器，就不能被子类化；与其他的静态方法实际上没有任何区别。

2·遇到多个构造器参数时要考虑用构建器

3·用私有构造器或者枚举类型强化Singleton属性：
公有静态成员
public class Elvis{
	public static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
}
公有静态方法
public class Elvis{
	private static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
	public static Elvis getInstance(){return INSTANCE;}
}
枚举
public enum Elvis{
	INSTANCE;
}
这种方法在功能上与公有域方法相近，但是它更加简洁，无偿的提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现singleton的最佳方法。

//TODO 深入了解一下enum


4·通过私有构造器强化不可实例化的能力
企图通过将类做成抽象类来强制该类不可被实例化，这是行不通的，因为子类可以实例化。
public class Utility{
	private Utility(){
		throw new AssertionError();
	}
}

5·避免创建不必要的对象
Map接口的keySet方法返回该Map对象的Set视图，其中包含该Map中所有的key。粗看起来，好像每次调用keySet都返回同样的Set实例,但是，对于一个给定的Map对象，实际上每次调用keySet都返回同样的Set实例。
优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。
清空对象引用应该是一种例外，而不是一种规范行为。
只要类是自己管理内存，程序员就应该警惕内存泄露问题。

6·消除过期的对象引用
过期引用obsolete reference。这类问题的修复方法很简单：一旦对象引用已经过期，只需清空这些引用即可。比如Stack的pop方法
public Object pop(){
	Object result = elements[--size];
	elements[size] = null;
	return result;
}

7·避免使用终结方法
如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法(或者有意选择不调用超类的终结方法)，那么超类的终结方法将永远也不会被调用到。


【对于所有对象都通用的方法】
Object的所有非final方法(equals，hashCode，toString，clone，finalize)都有明确的通用约定general contract，因为它们被设计成是要被覆盖override的。

8·覆盖equals时请遵守通用约定
equals方法实现了等价关系equivalence relation：自反性reflexive，对称性symmetric，传递性transitive，一致性consistent，非空性Non-nullity。
面向对象语言中关于等价关系的一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。
里氏替换原则Liskov substitution principle认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。
虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计workaround：复合优先于继承。
Timestamp扩展了Date，并增加了nanos域。所以有一个免责声明，不要混合使用Date和Timestamp对象。
实现高质量equals方法的诀窍：使用==操作符检查"参数是否为这个对象的引用"；使用instanceof操作符检查"参数是否为正确的类型";把参数转换成正确的类型;对于该类中的每个"关键significant"域，检查参数中的域是否与该对象中对应的域相匹配；问三个问题：是否对称，传递，一致。

9·覆盖equals时总要覆盖hashCode

10·始终要覆盖toString

11·谨慎地覆盖clone
Cloneable接口的目的是作为对象的一个mixin接口mixin interface。遗憾的是，它并没有成功地达到这个目的，主要缺陷在于缺少一个clone方法。
实际上，clone方法就是另一个构造器；你必须确保它不会伤害到原始的对象，并确保正确的创建被克隆对象的约束条件invariant

12·考虑实现Comparable接口
compareTo方法并没有在Object中声明。它是Comparable接口中唯一的方法。
类实现了Comparable接口，就表明它的实例具有内在的排序关系natural ordering。为实现Comparable接口的对象数组进行排序就这么简单:Arrays.sort(a);
compareTo方法的通用约定与equals方法的相似：将这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数.如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。

【类和接口】
13·使类和成员的可访问性最小化
模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏information hiding或封装encapsulation
对于顶层的(非嵌套的)类和接口，只有两种可能的访问级别:包级私有的(package-private)和公有的(public)
对于成员(域、方法、嵌套类和嵌套接口)有四种可能的访问级别:私有的(private)——只有在声明该成员的顶层类内部才可以访问这个成员;包级私有的(package-private)——声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为"缺省(default)访问级别"，如果没有为成员指定访问修饰符，就采用这个访问级别;受保护的(protected)——声明该成员的类的子类可以访问这个成员,并且该成员的包内部任何类也可以访问这个成员;共有的(public)——在任何地方都可以访问该成员。

14·在公有类中使用访问方法而非公有域
setter和getter方法

15·使可变性最小化
不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期lifetime内固定不变。
为了使类不会被扩展，要遵循下面五条规则:不要提供任何会修改对象状态的方法;保证类不会被扩展;使所有的域都成为私有的;使所有的域都是final的;确保对于任何可变组件的互斥访问。

16·复合优先于继承
简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性(fragility)。避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

17·要么为了继承而设计，并提供文档说明，要么就禁止继承
构造器决不能调用可被覆盖的方法。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。

18·接口优于抽象类
现有的类可以很容易被更新，以实现新的接口
接口是定义mixin(混合类型)的理想选择
接口允许我们构造非层次结构的类型框架
通过对你导出的每个重要的接口都提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。
接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。

19·接口只用于定义类型
避免常量接口constant interface
简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量

20·类层次优于标签类
避免标签类tagged class

21·用函数对象表示策略
简而言之，函数指针的主要用途就是实现策略(Strategy)模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员，并通过共有的静态final域被导出，其类型为该策略接口。

22·优先考虑静态成员类
嵌套类(nested class)是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类(enclosing class)提供服务。嵌套类有4种:静态成员类(static member class)、非静态成员类(nonstatic member class)、匿名类(anonymous class)和局部类(local class)

23·请不要再新代码中使用原生态类型
Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合;Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合;Set则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。

24·消除非受检警告
如果无法消除警告，同时可以证明引起警告的代码是类型安全的，(只有在这种情况下)才可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。

25·列表优先于数组
数组是协变的(covariant)。Sub为Super的子类型，Sub[]就是Super[]的子类型。
泛型是不可变的(invariant)。List<Type1>和List<Type2>没什么关系。
总而言之，数组和泛型有着非常不同的类型规则。数组是协变且可以具体化的;泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全。

26·优先考虑泛型
总而言之，使用泛型比使用需要在客户端代码中进行转换的类型来的更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。

27·优先考虑泛型方法
总而言之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来的更加安全，也更加容易。就像类型一样，你应该确保新方法可以不用转换就能使用，这通常意味着要将它们泛型化。

28·利用有限制通配符来提升API的灵活性
PECS表示producer-extends,consumer-super。换句话说，如果参数化类型表示一个T生产者，就使用<? extends T>;如果它表示一个T消费者，就使用<? super T>。

29·优先考虑类型安全的异构容器
总而言之，集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用Class对象作为键。以这种方式使用的Class对象称作类型令牌。

30·用enum代替int常量
 许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于"每个常量与属性的关联"以及"提供行为受到这个属性影响的方法"。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个枚举常量同事共享相同的行为，则考虑策略枚举。

31·用实例域代替序数
 所有的枚举都有一个ordinal方法，它返回每个枚举常量在类型中的数字位置。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

32·用EnumSet代替位域
总而言之，正是因为枚举类型要用在集合(Set)中，所以没有理由用位域来表示它。

33·用EnumMap代替序数索引
总而言之，最好不要用序数来索引数组，而要使用EnumMap。如果你所表示的这种关系是多维的，就使用EnumMap<...,EnumMap<...>>。应用程序的程序员在一般情况下都不适用Enum.ordinal，即使要用也很少，因此这是一种特殊情况。

34·用接口模拟可伸缩的枚举
总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。

35·注解优先于命名模式
除了"工具铁匠(toolsmiths——特定的程序员)"之外，大多数程序员都不必定义注解类型。但是所有的程序员都应该使用Java平台所提供的预定义的注解类型。还要考虑使用IDE或者静态分析工具所提供的任何注解。

36·坚持使用Override注解
应该在你想要覆盖超类声明的每个方法生命中使用override注解


37·用标记接口定义类型
标记接口(marker interface)是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。
总而言之，标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。


38·检查参数的有效性
简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。

39·必要时进行保护性拷贝
保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。
简而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改收到影响的组件，以此来代替保护性拷贝。

40·谨慎设计方法签名
谨慎地选择方法的名称
不要过于追求提供便利的方法
避免过长的参数列表
对于参数类型，要优先使用接口而不是类
对于boolean参数，要优先使用两个元素的枚举类型。

41·慎用重载
对于重载方法(overloaded method)的选择是静态的，而对于被覆盖的方法(overridden method)的选择则是动态的。调用哪个重载(overloading)方法是在编译时做出决定的。
给出三层建议:尽量避免重载方法;避免同一组参数只需要经过类型转换就可以被传递给不同的重载方法;当传递同样的参数时，所有重载方法的行为必须一致。

42·慎用可变参数
简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。

43·返回零长度的数组或者集合，而不是null
简而言之，返回类型为数组或者集合的方法没理由返回null，而不是返回一个零长度的数组或者集合。

44·为所有导出的API元素编写文档注释
为了正确编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。
方法的文档注释应该简洁地描述出它和客户端之间的约定。
为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。为枚举类型编写方法时，要确保在文档中说明常量。为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。
简而言之，要为API编写文档，文档注释是最好、最有效的途径。对于所有可导出的API元素来说，使用文档注释应该被看做是强制性的。

45·将局部变量的作用域最小化
循环中提供了特殊的机会来将变量的作用域最小化。因此，如果在循环终止之后不再需要循环变量的内容，for循环就优先于while循环。

46·for-each循环优先于传统的for循环
有三种常见的情况无法使用for-each循环：
过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove方法。
转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
平行迭代——如果需要平行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。

47·了解和使用类库
总而言之，不要重新发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。

48·如果需要精确的答案，请避免使用float和double
总而言之，对于任何需要精确答案的计算任务，请不要使用float或者double。
如果数值范围没有超过9位十进制数字，就可以使用int；如果不超过18位数字，就可以使用long；如果数值可能超过18位数字，就必须使用BigDecimal

49·基本类型优先于装箱基本类型
基本类型和装箱基本类型有三个主要区别:
基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。
基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有个非功能值:null。
基本类型通常比装箱基本类型更节省时间和空间。
总之，自动装箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险。当程序用==操作符比较两个装箱基本类型是，它做了个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出NullPoinerException异常。最后，当程序装箱了基本类型值时，会导致高开销和不必要的对象创建。

50·如果其他类型更适合，则尽量避免使用字符串。
总而言之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更加不灵活、速度更慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型、和聚集类型。

51·当心字符串连接的性能
使用StringBuilder的append方法。另一种方法使用字符数组。

52·通过接口引用对象
实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活；如果不是，则使用类层次结构中提供了必要功能的最基础的类。

53·接口优先于反射机制
核心反射机制(core reflection facility)java.lang.reflect，提供了"通过程序来访问关于已装载的类的信息"的能力。
简而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。如果你编写的程序必须要与编译时未知的类一起工作，如果有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类。

54·谨慎地使用本地方法
Java Native Interface(JNI)允许Java应用程序可以调用本地方法(native method)。
总而言之，在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。

55·谨慎地进行优化
总而言之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计API、线路层协议和永久数据格式的时候，一定要考虑性能的因素。

56·遵守普通接受的命名惯例
总而言之，把标准的命名惯例当作一种内在的机制来看待，并且学着用它们作为第二特性。

57·只针对异常的情况才使用异常
顾名思义，异常应该只用于异常的情况下；它们永远不应该用于正常的控制流。

58·对可恢复的情况使用受检异常，对编程错误使用运行时异常
Java程序设计语言提供了三种可抛出结构(throwable):受检异常(checked exception)、运行时异常(run-time exception)和错误(error).
如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。
对于程序错误，则使用运行时异常。

59·避免不必要地使用受检异常
受检的异常是Java程序设计语言的一项很好的特性。与返回代码不同，它们强迫程序员处理异常的条件，大大增强了可靠性。也就是说，过分使用受检的异常会使API使用起来非常不方便。

60·优先使用标准的异常
专家级程序员与缺乏经验的程序员一个最主要的区别在于，专家最求并且通常也能够实现高度的代码重用。

61·抛出与抽象相对应的异常
更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为异常转译(exception translation)。
一种特殊的异常转译形式称为异常链(exception chaining),如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。

62·每个方法抛出的异常都要有文档
始终要单独地声明受检的异常，并且利用Javadoc的@throws标记，准确地记录下抛出的每个异常的条件。但是不要使用throws关键字将未受检的异常包含在方法的声明中。
如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接受的，而不是为每个方法单独建立文档。

63·在细节消息中包含能捕获失败的信息
为了捕获失败，异常的细节信息应该包含所有"对该异常有贡献"的参数和域的值。

64·努力使失败保持原子
一般而言，失败的方法调用因该使对象保持在被调用之前的状态。具有这种属性的方法别称为具有失败原子性(failure atomic)
获得失败原子性办法:在执行前检查参数的有效性;调整计算处理的过程顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生;编写一段恢复代码(recovery code)

65·不要忽略异常
当API的设计者声明一个方法将抛出某个异常的时候，他们等于正在试图说明某些事情。所以，请不要忽略它。

66·同步访问共享的可变数据
为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。
活性失败(liveness failure):程序无法前进。
安全性失败(safety failure):程序会计算出错误的结果。
简而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。

67·避免过度同步
为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。
通常，你应该在同步区域做尽可能少的工作。
简而言之，为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽量限制同步区域内部的工作量。当你在涉及一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。

68·executor和task优先于线程
在Java 1.5发行版中，Java平台中增加了java.util.concurrent。这个包中包含了一个Executor Framework，这是一个很灵活的基于接口的任务执行工具。

69·并发工具优先于wait和notify
既然正确地使用wait和notify比较困难，就应该用更高级的并发工具来代替。
简而言之，直接使用wait和notify就像用"并发汇编语言"进行编程一样，而java.util.concurrent则提供了更高级的语言。

70·线程安全性的文档化
不可变的(immutable)——这个类的实例是不可变的。所以不需要外部的同步。如String、Long和BigInteger。
无条件的线程安全(unconditionally thread-safe)——这个类的实例是可变的，但是这个类有着足够的内不同步，所以它的实例可以被并发使用，不需任何外部同步。如Random和ConcurrentHashMap。
有条件的线程安全(conditionally thread-safe)——除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。如Collection.synchronized包装返回的集合，它们的迭代器(iterator)要求外部同步。
非线程安全(not thread-safe)——这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用。如ArrayList、HashMap。
线程对立的(thread-hostile)——这个类不能安全地被多个线程并发使用，即使所有调用都被外部同步包围。
简而言之，每个类都应该利用字斟句酌的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。

71·慎用延迟初始化
大多数情况下，正常的初始化要优先于延迟初始化。
如果利用延迟优化来破坏初始化的循环，就要使用同步访问方法。
如果出于性能的考虑而需要对静态域使用延迟初始化，就是用lazy initialization holder class模式
如果出于性能的考虑而需要对实例域使用延迟初始化，就是用双重检查模式(double-check idiom)。
对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式(single-check idiom)。

72·不要依赖于线程调度器
任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的。

73·避免使用线程组
总而言之，线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。我们最好把线程组看作是一个不成功的实验，你可以忽略掉它们。

74·谨慎地实现Serializable接口
实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了"改变这个类的实现"的灵活性。
实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性。
实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了。

75·考虑使用自定义的序列化形式
总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。