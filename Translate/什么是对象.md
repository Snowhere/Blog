原文[What Is an Object?](https://dzone.com/articles/who-is-an-object)
(译文发布在[码农网](http://www.codeceo.com/article/what-is-object.html))

#什么是对象
我们有成千上万的面相对象书籍和成百上千的面相对象语言,我相信它们大多数给我们关于对象的定义是错误的。这就是为什么整个面向对象世界充满误解与错误。它们给对象的定义基于所采用硬件架构,所以很原始很机械。我想介绍一种更好地定义。

什么是对象？我做了一些小调查,发现如下回答：
* "对象一般以域的形式包含数据,通常称作属性；以程序的形式包含代码,通常称作方法"——文章编写时摘自[Wikipedia](https://en.wikipedia.org/wiki/Object-oriented_programming).
* "对象在域中储存自身状态并通过方法暴露自身行为"——摘自Oracle.[What Is an Object?](https://docs.oracle.com/javase/tutorial/java/concepts/object.html)
* "每个对象就如一个小型电脑——它有状态,并且它提供操作,你可以调用执行"——[Thinking in Java](http://amzn.to/1PBmQpm)第4版,Bruce Eckel,第16页。
* "一个类包含了存放数值的数据域和操作数值的的方法"——[Java in a Nutshell](http://amzn.to/28PEqSi)第6版,Evans and Flanagan,第98页。
* "一个对象就是储存某些类型的值的内存空间"——[The C++ Programming Language](http://amzn.to/1XyGCtk),第4版,Bjarne Stroustrup,第40页。
* "一个对象包含一些私有内存空间和一些操作"——[Smalltalk-80](http://amzn.to/1UhYinp),Goldberg and Robson,第6页。

这些定义都用了一个词"包含"(或"储存","有",等等)。他们都认为对象是个存放数据的盒子。而这个观点恰恰是我强烈反对的。

如果我们看一看C++或Java如何实现的,以上对于对象的定义听起来在技术上是正确的。确实,对于每个对象,Java虚拟机开辟一些字节的内存来存放对象的属性。因此,我们在技术上可以宣称,在这些语言中,对象就是内存空间中存储数据的盒子。

正确,但这太片面了。

让我们来想象另一种面相对象语言,它不在内存中存放对象的属性。一脸懵逼吗？先忍耐我几分钟。让我们来看看在这种与语言中定义一个对象：
```
c {
    vin: v,
    engine: e
}
```
这里,vin(车辆识别码)和engine(发动机)是对象c的属性(c是一辆车car；让我们暂时忘记类,专注于对象).因此,这仅仅是包含两个属性的对象。第一个是车的车辆识别码,第二个是它的发动机。车辆识别码是v对象,发动机是e对象。为了更好理解,Java中可以这样表示：
``` java
char[] v = {'W','D','B','H',...'7','2','8','8'}; // 17 chars
Engine e = new Engine();
Car c = new Car(v, e);
```
对于Java虚拟机我不太了解,不过在C++中,这样的对象会占用25字节的内存(在64位x86架构下)。前面17字节储存字符数组,后8个字节是指向对象e所在内存块的指针。这就是C++编译器如何理解对象,并把它们应用于x86架构。在C++中,对象就是各数据属性被清晰定义配置的数据结构。

在这个例子中,属性vin和engine并不相同:vin是"数据",engine是指向另一个对象的"指针"。我这样设计的目的就是展示只有vin可以称得上是存放数据的盒子。只有当数据确实在对象内部的时候,我们才能称对象是存放数据的盒子。对于engine,这并不正确,因为数据并没有真正在对象内部,它是通过指针指向另一个对象。如果我们的对象只有engine属性,那它只占8字节的内存,而且并不是真正的数据。

现在,回到我们虚构的语言中。让我们想象一种区别于C++的处理对象的方式——并不在内存中保存对象属性。它没有指针,也不了解x86架构。它只知道属性属于对象。

因此,在我们这个语言中,在技术概念上对象不再是存放数据的盒子。它们知道数据在哪里,但是它们不包含数据。它们表示数据,就像其他对象和实体一样。的确,对象c在我们想象的语言中表示两个其他对象：vin(车辆识别码)和engine(发动机)。

简而言之,我们要明白尽管在大多数编程语言中对对象的机械定义是正确的,但把对象当做存放数据的盒子在概念上是不正确的。这会驱使我们程序化思考并尝试访问数据。

如果我们把对象作为数据的"表示(representative)"而不是容器,我们不会立刻去获取数据。我们会明白数据遥不可及。我们与对象交互——而且并不需要关心对象如何与数据交互。

我希望在不久的将来,会出现一种新的面相对象语言,不把对象作为数据结构存放在内存中,甚至是在技术层面上。

顺便说一下,这是我最喜欢的书定义的对象[Object Thinking](http://amzn.to/266oJr4),David West,第66页：
***
对象相当于构成宇宙的量子。
***
你怎么想？是否和我提出的"表征(representative)"有异曲同工之妙呢？
